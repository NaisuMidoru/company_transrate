ご提示いただいた要件（C#側でのリトライ完結、C++は結果表示のみ、リスク許容、ログ保存なし、再起動なし）に基づき、**最も実装コストが低く、かつ運用に耐えうる「現実的なエラー処理仕様」**を策定しました。

また、ご質問の「4プロセス構成」についても、エラーハンドリングの観点から改善案を提示します。

---

## 1. アーキテクチャ構成の見直し（推奨）

**現状：** 画像4枚指定時に C#プロセスを4つ起動する。
**評価：** **非推奨です。** エラーハンドリングが非常に複雑になります（C++が4つのプロセスの結果を合算・管理する必要があるため）。

**改善案：** **「シングルプロセス・マルチスレッド」**
C#プロセスは1つだけ起動し、内部で非同期処理(`Task`)を用いて4つの画像を並列処理します。

*   **メリット:**
    *   C++は1つのJSON結果を受け取るだけで済む（実装がシンプル）。
    *   アクセストークン管理が1回で済む。
    *   「3枚成功、1枚失敗」のような結果をまとめて返せる。

**※以下の仕様は、この「シングルプロセス（C#内部で並列化）」構成を前提に記述します。**

---

## 2. C# ⇔ C++ インターフェース仕様

C#アプリは処理終了時、標準出力に以下のJSONを出力し、終了します。

```json
{
  "status": "SUCCESS",      // 成功
            "PARTIAL",      // 一部成功（4枚中3枚など）
            "ERROR",        // 全失敗
  "message": "完了しました。", // C++がそのままダイアログに表示する文字列
  "details": {              // ログ用または詳細表示用
    "successCount": 3,
    "totalCount": 4,
    "errorCode": "E500"
  }
}
```

---

## 3. フェーズ別エラー処理・リトライ仕様完全網羅表

「リスク許容（課金漏れOK）」かつ「複雑なリカバリ（ログ保存・再起動）なし」の前提で、C#内部で可能な限りの努力（リトライ）を行う設計です。

### Phase 1: 署名付きURL発行 (C# -> APIGW -> Lambda)
*   **目的:** 画像アップロード用の場所を確保する。

| エラー要因 | 具体的な事象 | C# 内部リトライ | C++ への最終通知 (Message) |
| :--- | :--- | :--- | :--- |
| **認証** | アクセストークン切れ (401/403) | **なし** (即死) | 「認証の有効期限が切れました。再ログインしてください。」 |
| **通信** | ネット切断 / DNS解決失敗 | **あり** (3回) | 「インターネット接続を確認してください。」 |
| **AWS** | APIGW 502/504 / Lambda エラー | **あり** (3回) | 「サーバーが混み合っています。しばらく待って再試行してください。」 |

### Phase 2: 画像アップロード (C# -> S3)
*   **目的:** 入力画像をクラウドへ送る。

| エラー要因 | 具体的な事象 | C# 内部リトライ | C++ への最終通知 (Message) |
| :--- | :--- | :--- | :--- |
| **ファイル** | ファイルが開けない / ロック中 | **なし** | 「画像ファイルが開けません。他のアプリで開かれていないか確認してください。」 |
| **通信** | アップロード中断 | **あり** (AWS SDK任せ) | 「画像のアップロードに失敗しました。通信環境を確認してください。」 |

### Phase 3: 画像生成 (C# -> APIGW -> Lambda -> S3)
*   **構造:** C#から並列でリクエストを投げます。
*   **重要:** **Lambda/APIGWの不具合（タイムアウト等）はここで発生します。**

| エラー要因 | 具体的な事象 | C# 内部リトライ | C++ への最終通知 (Message) |
| :--- | :--- | :--- | :--- |
| **タイムアウト** | **APIGW 504 (29秒制限)** | **なし**<br>※リトライしても再度タイムアウトする可能性が高く、課金対象のリソースを消費するため。 | (全滅時)<br>「処理がタイムアウトしました。画像サイズ等を変更して再試行してください。」 |
| **AWS障害** | APIGW 500/502 / Lambda Crash | **あり** (1回のみ)<br>※一時的な障害の可能性があるため。 | (全滅時)<br>「画像生成サーバーでエラーが発生しました。」 |
| **論理エラー** | パラメータ不正 (400) | **なし** | 「設定値が不正です。入力内容を確認してください。」 |
| **★部分成功** | 4枚中1枚だけタイムアウト等 | - | **ステータス: PARTIAL**<br>「4枚中3枚の生成に成功しました。(1枚はエラー)」 |

### Phase 4: 画像ダウンロード (C# <- S3)
*   **重要:** ここが成功した時点でユーザーに成果物が渡ります。

| エラー要因 | 具体的な事象 | C# 内部リトライ | C++ への最終通知 (Message) |
| :--- | :--- | :--- | :--- |
| **S3** | 404 Not Found (生成遅延) | **あり** (1秒待機×3回) | 「生成された画像の取得に失敗しました。」 |
| **ディスク** | 容量不足 / 書き込み権限なし | **なし** | 「保存に失敗しました。ディスクの空き容量や権限を確認してください。」 |

### Phase 5: 課金処理 (C# -> APIGW -> Lambda -> 自社システム)
*   **前提:** 画像はPhase 4でダウンロード済み。
*   **方針:** 「ログ保存なし」のため、**ここで失敗したら課金漏れ（タダ乗り）として終了します。**

| エラー要因 | 具体的な事象 | C# 内部リトライ | C++ への最終通知 (Message) |
| :--- | :--- | :--- | :--- |
| **認証** | **トークン期限切れ (401)** | **なし**<br>※仕様により諦める。 | **「画像は保存されましたが、セッション切れのため決済処理に失敗しました。」**<br>(ユーザーは画像を利用可能) |
| **自社システム** | **システムダウン / 応答なし (5xx)** | **強固にあり** (5回)<br>※ここだけは粘る。 | **「画像は保存されましたが、決済サーバーとの通信に失敗しました。」**<br>(ユーザーは画像を利用可能) |
| **決済拒否** | **カード限度額オーバー等 (400/402)** | **なし** | **「画像は保存されましたが、決済が承認されませんでした。カード情報をご確認ください。」**<br>(ユーザーは画像を利用可能) |
| **正常** | 200 OK | - | **「生成が完了しました。」** |

---

## 4. 自問自答：考慮漏れチェックとQ&A

ご懸念の「APIGW/Lambdaの不具合」や「自社システムの不具合」に対する具体的な挙動です。

#### Q1. Lambdaの不具合（コードバグやメモリ不足）で強制終了したら？
*   **対応:** Phase 3で APIGW から `502 Bad Gateway` または `500 Internal Server Error` が返ってきます。
*   **挙動:** C#はこれを検知し、1回だけリトライします。それでもダメなら「生成サーバーエラー」として処理を終えます。C++には「エラーが発生しました」と表示されます。
*   **課金:** 画像ができていないので、Phase 4, 5には進まず、課金もされません。**問題ありません。**

#### Q2. APIGWのタイムアウト（29秒）が発生したら？
*   **対応:** C#並列処理により、1枚ごとに29秒の判定が行われます。
*   **挙動:** 間に合った画像はPhase 4へ、間に合わなかった画像はエラー扱いになります。
*   **課金:** C#は「成功した画像の枚数分」だけをPhase 5で課金リクエストします。**適正な課金が行われます。**

#### Q3. 自社課金システムに不具合があり、応答が帰ってこなかったら？
*   **対応:** C#はタイムアウトまで待ち、数回リトライします。
*   **挙動:** 最終的にエラーとなり、C++には「画像は保存されましたが、決済通信に失敗しました」と表示されます。
*   **結果:** **課金漏れ（タダ乗り）が発生します。**
*   **判定:** 「仕様のため許容する」という前提条件に合致するため、**これでOKとします。**

#### Q4. 複数画像処理中にトークンが切れたら？
*   **対応:** Phase 3（生成）まではアクセストークンが有効でも、Phase 5（課金）の瞬間に切れる可能性があります。
*   **挙動:** 課金APIが `401 Unauthorized` を返します。
*   **結果:** リトライせずエラーメッセージを表示して終了します。画像は手元に残り、課金はされません。これも仕様上許容します。

---

## 5. まとめ

この設計は、**「C#側で粘れるだけ粘るが、ダメなら潔くエラー報告して終わる」** という方針です。

1.  **C#プロセス:** シングルプロセス化し、内部で並列処理を行う（推奨）。
2.  **リトライ:** 通信エラーやサーバーエラー（5xx）に対してはC#内部で数回行う。
3.  **課金エラー:** 画像ダウンロード後のエラーは、ユーザーに「決済失敗」を伝えるが、画像の削除やロックは行わない（タダ乗り許容）。
4.  **C++:** C#から返ってきたJSONの `message` をダイアログに出すだけで完了。

この表と仕様に基づいて実装すれば、混乱なく、かつ要件（リスク許容・実装コスト抑制）を満たしたシステムになります。

@@------

おっしゃる通りです。そのご指摘はシステム設計において**最も重要な核心部分**です。

Phase 5（課金フェーズ）でC#側がリトライ（再送）を行う場合、受け取る側の「自社独自の課金処理システム」には、**「あ、このリクエストさっき処理したやつだ」と気づく仕組み（冪等性：べきとうせい）** が絶対に必要です。

これがないと、C#が「タイムアウトだ、もう一回送ろう」とリトライするたびに、ユーザーに二重、三重の請求が行われてしまいます。

この仕組みを実装するための具体的な仕様を整理しました。

---

### 1. 決済ID（Transaction ID）の運用ルール

このIDは、「**1回の画像生成セットに対する課金**」を一意に識別するものです。

1.  **誰が作るか？**
    *   **クライアントアプリ（C# exe）** が生成します。
    *   Phase 4（ダウンロード）が完了し、Phase 5（課金）に入る直前に生成します。
2.  **どんな値か？**
    *   **UUID (GUID)** 推奨です。（例: `550e8400-e29b-41d4-a716-446655440000`）
    *   他と絶対に被らないユニークな文字列であれば何でも構いません。
3.  **どう使うか？**
    *   C#アプリは、1回目の送信時も、エラーでリトライする2回目以降の送信時も、**同じIDを使い回して送信します**。
    *   **重要:** リトライのたびに新しく作り直してはいけません。

---

### 2. データフロー（JSONイメージ）

**C# → 課金API (Request)**
```json
{
  "accessToken": "ey...",        // 認証用
  "transactionId": "abc-123",    // ★ここが決済ID（リトライ中はずっと同じ値）
  "amount": 100,                 // 金額
  "itemCount": 1                 // 枚数
}
```

---

### 3. サーバー側（自社課金システム）の必須実装

課金システム側には、以下のロジックを実装する必要があります。

#### データベース設計
`PaymentHistory` テーブルを用意します。
*   `transaction_id` (主キー): クライアントから送られてきたID
*   `status`: "SUCCESS" (課金済み), "PENDING" (処理中), "FAILED" (失敗)
*   `created_at`: 日時

#### 処理ロジック (API受信時の挙動)

1.  **ID検索:** DBを `transactionId` で検索する。
2.  **パターンA：レコードがない場合（初回リクエスト）**
    *   課金処理を実行する。
    *   成功したら DBに `transactionId` と `status="SUCCESS"` を保存する。
    *   クライアントに `200 OK` を返す。
3.  **パターンB：レコードがあり、Status="SUCCESS" の場合（リトライリクエスト）**
    *   **課金処理はスキップする（二重課金防止）。**
    *   「もう終わってるよ」という意味で、即座に `200 OK` を返す。
4.  **パターンC：レコードがあり、Status="FAILED" の場合**
    *   前回失敗しているので、再挑戦として課金処理を実行する。

---

### 4. タイムアウト時の具体的な救済フロー

この仕組みがあれば、以下のようなトラブルが起きても安全です。

1.  **C#:** 課金リクエスト送信 (`ID: A001`)
2.  **サーバー:** 課金成功！ カード決済完了！ DBに `ID: A001` 保存！
3.  **ネットワーク:** **サーバーからの「完了しました」レスポンスが、C#に届く前に通信が切れた。**
4.  **C#:** 「返事が来ない…タイムアウトだ。失敗したかな？ **リトライしよう**」
5.  **C#:** 再度リクエスト送信 (`ID: A001` をそのまま使用)
6.  **サーバー:** 「お、`ID: A001` がまた来たな。DBを見ると…**さっき完了してる**」
7.  **サーバー:** 課金処理はせず、即座に `200 OK` を返す。
8.  **C#:** 「成功した！」と判断して終了。

**→ 結果：課金は1回のみ。ユーザーには正常終了として表示される。**

---

### 5. 結論：仕様への追加事項

「リトライ処理をC#側で行う」という要件を実現するためには、以下の記述を仕様に追加してください。

*   **C#仕様:** 課金リクエスト時に UUID を生成し、リトライ時はその UUID を保持して送信すること。
*   **課金システム仕様:** 受信した UUID (Transaction ID) を記録し、同一 ID のリクエストが来た場合は課金処理を行わず、前回の結果を返すこと（冪等性の担保）。

これで、**「ネットワークエラーによる再送」** と **「二重課金リスク」** の矛盾を解決できます。
