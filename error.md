ご提示いただいた要件（C#側でのリトライ完結、C++は結果表示のみ、リスク許容、ログ保存なし、再起動なし）に基づき、**最も実装コストが低く、かつ運用に耐えうる「現実的なエラー処理仕様」**を策定しました。

また、ご質問の「4プロセス構成」についても、エラーハンドリングの観点から改善案を提示します。

---

## 1. アーキテクチャ構成の見直し（推奨）

**現状：** 画像4枚指定時に C#プロセスを4つ起動する。
**評価：** **非推奨です。** エラーハンドリングが非常に複雑になります（C++が4つのプロセスの結果を合算・管理する必要があるため）。

**改善案：** **「シングルプロセス・マルチスレッド」**
C#プロセスは1つだけ起動し、内部で非同期処理(`Task`)を用いて4つの画像を並列処理します。

*   **メリット:**
    *   C++は1つのJSON結果を受け取るだけで済む（実装がシンプル）。
    *   アクセストークン管理が1回で済む。
    *   「3枚成功、1枚失敗」のような結果をまとめて返せる。

**※以下の仕様は、この「シングルプロセス（C#内部で並列化）」構成を前提に記述します。**

---

## 2. C# ⇔ C++ インターフェース仕様

C#アプリは処理終了時、標準出力に以下のJSONを出力し、終了します。

```json
{
  "status": "SUCCESS",      // 成功
            "PARTIAL",      // 一部成功（4枚中3枚など）
            "ERROR",        // 全失敗
  "message": "完了しました。", // C++がそのままダイアログに表示する文字列
  "details": {              // ログ用または詳細表示用
    "successCount": 3,
    "totalCount": 4,
    "errorCode": "E500"
  }
}
```

---

## 3. フェーズ別エラー処理・リトライ仕様完全網羅表

「リスク許容（課金漏れOK）」かつ「複雑なリカバリ（ログ保存・再起動）なし」の前提で、C#内部で可能な限りの努力（リトライ）を行う設計です。

### Phase 1: 署名付きURL発行 (C# -> APIGW -> Lambda)
*   **目的:** 画像アップロード用の場所を確保する。

| エラー要因 | 具体的な事象 | C# 内部リトライ | C++ への最終通知 (Message) |
| :--- | :--- | :--- | :--- |
| **認証** | アクセストークン切れ (401/403) | **なし** (即死) | 「認証の有効期限が切れました。再ログインしてください。」 |
| **通信** | ネット切断 / DNS解決失敗 | **あり** (3回) | 「インターネット接続を確認してください。」 |
| **AWS** | APIGW 502/504 / Lambda エラー | **あり** (3回) | 「サーバーが混み合っています。しばらく待って再試行してください。」 |

### Phase 2: 画像アップロード (C# -> S3)
*   **目的:** 入力画像をクラウドへ送る。

| エラー要因 | 具体的な事象 | C# 内部リトライ | C++ への最終通知 (Message) |
| :--- | :--- | :--- | :--- |
| **ファイル** | ファイルが開けない / ロック中 | **なし** | 「画像ファイルが開けません。他のアプリで開かれていないか確認してください。」 |
| **通信** | アップロード中断 | **あり** (AWS SDK任せ) | 「画像のアップロードに失敗しました。通信環境を確認してください。」 |

### Phase 3: 画像生成 (C# -> APIGW -> Lambda -> S3)
*   **構造:** C#から並列でリクエストを投げます。
*   **重要:** **Lambda/APIGWの不具合（タイムアウト等）はここで発生します。**

| エラー要因 | 具体的な事象 | C# 内部リトライ | C++ への最終通知 (Message) |
| :--- | :--- | :--- | :--- |
| **タイムアウト** | **APIGW 504 (29秒制限)** | **なし**<br>※リトライしても再度タイムアウトする可能性が高く、課金対象のリソースを消費するため。 | (全滅時)<br>「処理がタイムアウトしました。画像サイズ等を変更して再試行してください。」 |
| **AWS障害** | APIGW 500/502 / Lambda Crash | **あり** (1回のみ)<br>※一時的な障害の可能性があるため。 | (全滅時)<br>「画像生成サーバーでエラーが発生しました。」 |
| **論理エラー** | パラメータ不正 (400) | **なし** | 「設定値が不正です。入力内容を確認してください。」 |
| **★部分成功** | 4枚中1枚だけタイムアウト等 | - | **ステータス: PARTIAL**<br>「4枚中3枚の生成に成功しました。(1枚はエラー)」 |

### Phase 4: 画像ダウンロード (C# <- S3)
*   **重要:** ここが成功した時点でユーザーに成果物が渡ります。

| エラー要因 | 具体的な事象 | C# 内部リトライ | C++ への最終通知 (Message) |
| :--- | :--- | :--- | :--- |
| **S3** | 404 Not Found (生成遅延) | **あり** (1秒待機×3回) | 「生成された画像の取得に失敗しました。」 |
| **ディスク** | 容量不足 / 書き込み権限なし | **なし** | 「保存に失敗しました。ディスクの空き容量や権限を確認してください。」 |

### Phase 5: 課金処理 (C# -> APIGW -> Lambda -> 自社システム)
*   **前提:** 画像はPhase 4でダウンロード済み。
*   **方針:** 「ログ保存なし」のため、**ここで失敗したら課金漏れ（タダ乗り）として終了します。**

| エラー要因 | 具体的な事象 | C# 内部リトライ | C++ への最終通知 (Message) |
| :--- | :--- | :--- | :--- |
| **認証** | **トークン期限切れ (401)** | **なし**<br>※仕様により諦める。 | **「画像は保存されましたが、セッション切れのため決済処理に失敗しました。」**<br>(ユーザーは画像を利用可能) |
| **自社システム** | **システムダウン / 応答なし (5xx)** | **強固にあり** (5回)<br>※ここだけは粘る。 | **「画像は保存されましたが、決済サーバーとの通信に失敗しました。」**<br>(ユーザーは画像を利用可能) |
| **決済拒否** | **カード限度額オーバー等 (400/402)** | **なし** | **「画像は保存されましたが、決済が承認されませんでした。カード情報をご確認ください。」**<br>(ユーザーは画像を利用可能) |
| **正常** | 200 OK | - | **「生成が完了しました。」** |

---

## 4. 自問自答：考慮漏れチェックとQ&A

ご懸念の「APIGW/Lambdaの不具合」や「自社システムの不具合」に対する具体的な挙動です。

#### Q1. Lambdaの不具合（コードバグやメモリ不足）で強制終了したら？
*   **対応:** Phase 3で APIGW から `502 Bad Gateway` または `500 Internal Server Error` が返ってきます。
*   **挙動:** C#はこれを検知し、1回だけリトライします。それでもダメなら「生成サーバーエラー」として処理を終えます。C++には「エラーが発生しました」と表示されます。
*   **課金:** 画像ができていないので、Phase 4, 5には進まず、課金もされません。**問題ありません。**

#### Q2. APIGWのタイムアウト（29秒）が発生したら？
*   **対応:** C#並列処理により、1枚ごとに29秒の判定が行われます。
*   **挙動:** 間に合った画像はPhase 4へ、間に合わなかった画像はエラー扱いになります。
*   **課金:** C#は「成功した画像の枚数分」だけをPhase 5で課金リクエストします。**適正な課金が行われます。**

#### Q3. 自社課金システムに不具合があり、応答が帰ってこなかったら？
*   **対応:** C#はタイムアウトまで待ち、数回リトライします。
*   **挙動:** 最終的にエラーとなり、C++には「画像は保存されましたが、決済通信に失敗しました」と表示されます。
*   **結果:** **課金漏れ（タダ乗り）が発生します。**
*   **判定:** 「仕様のため許容する」という前提条件に合致するため、**これでOKとします。**

#### Q4. 複数画像処理中にトークンが切れたら？
*   **対応:** Phase 3（生成）まではアクセストークンが有効でも、Phase 5（課金）の瞬間に切れる可能性があります。
*   **挙動:** 課金APIが `401 Unauthorized` を返します。
*   **結果:** リトライせずエラーメッセージを表示して終了します。画像は手元に残り、課金はされません。これも仕様上許容します。

---

## 5. まとめ

この設計は、**「C#側で粘れるだけ粘るが、ダメなら潔くエラー報告して終わる」** という方針です。

1.  **C#プロセス:** シングルプロセス化し、内部で並列処理を行う（推奨）。
2.  **リトライ:** 通信エラーやサーバーエラー（5xx）に対してはC#内部で数回行う。
3.  **課金エラー:** 画像ダウンロード後のエラーは、ユーザーに「決済失敗」を伝えるが、画像の削除やロックは行わない（タダ乗り許容）。
4.  **C++:** C#から返ってきたJSONの `message` をダイアログに出すだけで完了。

この表と仕様に基づいて実装すれば、混乱なく、かつ要件（リスク許容・実装コスト抑制）を満たしたシステムになります。
